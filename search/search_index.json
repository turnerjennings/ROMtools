{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ROMtools","text":"<p>Rigid Body Dynamics tools for 2-D reduced order modelling of structural dynamics</p>"},{"location":"#installation","title":"Installation","text":"<p>The package can be downloaded and installed using pip:</p> <pre><code>py -m pip install ROMtools\n</code></pre>"},{"location":"#project-overview","title":"Project Overview","text":"<p>The objective of this python package is to provide a set of tools for building simplified physics models of complex structural impact and dynamics problems.  The library includes flexible workflows for defining complex multibody dynamics problems and a object-oriented solver which allows for fast iteration and optimization of models.</p>"},{"location":"#parts-of-a-model","title":"Parts of a model","text":"<p>A reduced-order model is comprised of several components:</p> <ol> <li>Rigid bodies - objects of question in the analysis can be defined as a predetermined shape (disc, circle, semicircle) or as an arbitrary object by specifying mass and inertia properties.  Initial conditions for each body can also be specified.</li> <li>Springs and Dampers - Rigid bodies are connected to each other and to fixed boundaries by linear and rotational spring/damper systems.</li> <li>External loads - Additional external forces (gravity, impact loads) may be specified globally or applied to specific rigid bodies.</li> <li>Configuration - A configuration object is defined which stores information and settings for a solution to the model defined above.</li> <li>Solver - Model components and a configuration are passed to a solver object which performs the physics simulation and stores and saves the results.</li> <li>(Optional) Animator - A solver can be passed to an animator after a solution is obtained to create plots of the resultant behavior</li> </ol> <p>Each component is described in subsequent sections of the documentation.</p>"},{"location":"Animation/","title":"Animator","text":"<p>Handler for creating animated output plots illustrating model dynamics.</p>"},{"location":"Animation/#attributes","title":"Attributes","text":"Attribute Type Description time np.ndarray Solver timesteps n_timesteps int Number of timesteps in the analysis n_frames int Number of frames to render pos np.ndarray Position array from solution fps int Frames per second for saved animation concise bool Option to animate only dynamics system motion (True) or animate system motion plus position vs time plots (False) body_colors list [string] List of colors to render bodies from solver body_names list [string] List of body nicknames for legend rendering body_ID list [int] IDs for each body in the analysis springs list [SpringDamper] List of springs included in the analysis xlim, ylim, tlim tuple [float, float] Min and Max limits for animator plots in x, y, and theta metadata dict (optional) Optional metadata for rendered video path string save path for output render"},{"location":"Animation/#methods","title":"Methods","text":""},{"location":"Animation/#_init_","title":"_init_","text":"<pre><code>class Animator:\n\n    def __init__(\n        self,\n        sol: Solver,\n        fps: int = 15,\n        metadata: Optional[dict] = None,\n        xlim: Tuple[float, float] = None,\n        ylim: Tuple[float, float] = None,\n        tlim: Tuple[float, float] = None,\n    ) -&gt; None:\n\n#create animator from existing solution\nanim = Animator(solver)\n</code></pre> <p>inputs | Attribute |   Type   | Description| |---------|-------------|-------------| | sol | Solver | Solver result to animate | | fps | int (optional) | Frames per second to render video at. Defaults to 15 | | metadata | dict (optional) | Optional metadata to include in render | | xlim, ylim, tlim (optional) | tuple [float, float] | Option to manually specify x, y, theta limits for the animation window.  Limits will be automatically calculated if not specified |</p> <p>Returns Animator object</p>"},{"location":"Animation/#animate","title":"Animate","text":"<p>Render results from Animator and saves to file specified in solver/run configuration</p> <pre><code>\n#create animator from existing solution\nanim = Animator(solver)\n\n#render result\nanim.animate()\n</code></pre>"},{"location":"Forces/","title":"Boundary Conditions","text":"<p>External boundary conditions can be applied to the model in the form of forces or prescribed displacements (WIP).</p>"},{"location":"Forces/#forces","title":"Forces","text":"<p>External forces can be applied to a body along one its degrees of freedom.  Forces can be specified using a function, numpy vector, or scalar. </p>"},{"location":"Forces/#attributes","title":"Attributes","text":"Attribute Type Description bodies int or list[int] Body or list of bodies that the force acts on dof 0, 1, or 2 Degree of freedom the force acts on (1 = x, 2 = y, 3 = theta) t np.ndarray array of timesteps for the simulation ft np.ndarray value of the force function evaluated at each timestep"},{"location":"Forces/#methods","title":"Methods","text":""},{"location":"Forces/#_init_","title":"_init_","text":"<pre><code>class Force(BoundaryCondition):\n\n    def __init__(self,\n                 config: RunConfiguration, \n                 f: Union[float, np.ndarray, Callable[[np.ndarray], np.ndarray]], \n                 body: Union[List[int], int], \n                 dof: Literal[0, 1, 2], \n                 *args, \n                 **kwargs) -&gt; None:\n\n#Define a constant force of -1g in the y-direction\nfgrav = Force(config, -9.81, body=1, dof=1)\n\n#Define a sinusoidal force in the x-direction\na=5\ndef sinforce(t,a):\n    return a*np.sin(t)\nfsinusoid = Force(config, sinforce, 0, 0, a)\n\n</code></pre> <p>inputs</p> Attribute Type Description Config RunConfiguration Run configuration for the simulation f float or np.ndarray or function force definition body int or list [int] body or list of bodies that the force acts on dof 0 or 1 or 2 Degree of freedom the force acts on (1 = x, 2 = y, 3 = theta) args, kwargs Additional arguments required for f if f is a function <p>returns</p> <p>Force object</p> <p>notes</p> <p>If \\(f\\) is a scalar, ft is a consistent numpy array of that scalar.  If \\(f\\) is a numpy array, ft is that array with zero padding on the end to achieve the same length as the number of timesteps in the configuration file. If \\(f\\) is a function, it must accept an argument t, and ft will be the value of that function evaluated at each timestep in the numpy array t.</p>"},{"location":"Forces/#displacement","title":"Displacement","text":"<p>WIP</p>"},{"location":"RigidBody/","title":"Rigid Bodies","text":"<p>A class to define rigid objects of interest to perform rigid body dynamics simulation on.  All calculations are performed treating the x-, y-, and theta- movement of the center of mass as the degrees of freedom for the body.</p>"},{"location":"RigidBody/#attributes","title":"Attributes","text":"Attribute Type Description ID Int Identifier number for rigid body name String Nickname for the rigid body (used for labelling in Animator) m float Rigid body mass R float Rigid body radius (or radius of gyration for generalized objects) I float Rigid body mass moment of inertia x0 float Initial x-coordinate of the center of mass y0 float Initial y-coordinate of the center of mass t0 float Initial theta-orientation of the rigid body constraint tuple[bool, bool, bool] Degree of freedom constraints applied to the body (true = motion constrained in that degree of freedom) p0 tuple[float, float, float] Initial position of the rigid body v0 tuple[float, float, float] Initial velocity of the rigid body a0 tuple[float, float, float] Initial acceleration of the rigid body"},{"location":"RigidBody/#subclasses","title":"Subclasses","text":"<p>All subclasses share the same methods detailed below, but configure a pre-specified rigid body for simplicity.  Selection of pre-specified rigid body geometry affects moment of inertia calculation and animation rendering:</p> <ul> <li>Disc</li> <li>Semicircle</li> <li>Circle</li> </ul>"},{"location":"RigidBody/#methods","title":"Methods","text":""},{"location":"RigidBody/#init","title":"init","text":"<p>Initialize a new rigid body.  init method is identical for all subclasses.</p> <pre><code>class RigidBody:\n\n    def __init__(\n        self,\n        ID: int,\n        m: float,\n        R: float,\n        name: str = \"\",\n        cm: Tuple[float, float, float] = (0.0, 0.0, 0.0),\n        I: Optional[float] = None,\n        dof_constraint: Tuple[bool, bool, bool] = (False, False, False),\n    ) -&gt; None:\n\n#Define a solid disc rigid body with ID 0 located at the origin with no motion in the x-direction\ndisc = Disc(ID=0, m=1.12, R=1.56, name = \"body 1\", cm = (0.0,0.0,0.0), dof_constraint = (True, False, False))\n</code></pre> <p>inputs</p> Attribute Type Description ID Int ID for keyword object m Float Rigid body mass R Float Rigid body radius of gyration Name String (optional) Nickname for body, defaults to none cm Tuple[float, float, float] (optional) Center of mass of body, defaults to (0,0,0) I Float (optional) Rigid body moment of Inertia, if not specified, calculation depends on body type dof_constraint Tuple[bool, bool, bool] (optional) Degree-of-freedom constraints for body <p>returns</p> <p>Array Keyword object</p> <p>notes</p> <p>If a moment of inertia is not specified, the moment of inertia is calculated automatically using the appropriate formulation for the body type:</p> <ul> <li>RigidBody (treated as a thin circle): \\(I=m*R^2\\)</li> <li>Disc: \\(I=\\frac{m*R^2}{2}\\)</li> <li>Semicircle: \\(I=\\frac{m*R^2}{2}\\)</li> <li>circle: \\(I=m*R^2\\)</li> </ul>"},{"location":"RigidBody/#initial_conditions","title":"initial_conditions","text":"<p>Apply initial conditions to a rigid body</p> <pre><code>#Define a solid disc rigid body with ID 0 located at the origin with no motion in the x-direction\ndisc = Disc(ID=0, m=1.12, R=1.56, name = \"body 1\", cm = (0.0,0.0,0.0), dof_constraint = (True, False, False))\n\n#apply an initial displacement in the y-direction and an initial velocity in the theta direction\ndisc.initial_conditions(p=(0.0, 1.0, 0.0), v=(0.0, 0.0, 0.5))\n</code></pre> <p>inputs</p> Attribute Type Description p Tuple[float, float, float] (optional) Initial displacement, defaults to (0,0,0) v Tuple[float, float, float] (optional) Initial velocity, defaults to (0,0,0) a Tuple[float, float, float] (optional) Initial acceleration, defaults to (0,0,0) <p>returns</p> <p>None. Updates object attributes for initial conditions.</p>"},{"location":"RigidBody/#render_body","title":"render_body","text":"<p>Render the body in a given configuration on a plot.  Used in animation but can be called separately to render specific configurations</p> <pre><code>#Define a solid disc rigid body with ID 0 located at the origin with no motion in the x-direction\ndisc = Disc(ID=0, m=1.12, R=1.56, name = \"body 1\", cm = (0.0,0.0,0.0), dof_constraint = (True, False, False))\n\n#apply an initial displacement in the y-direction and an initial velocity in the theta direction\ndisc.initial_conditions(p=(0.0, 1.0, 0.0), v=(0.0, 0.0, 0.5))\n\n#create a plot\nfig, ax = plt.subplots()\n\nax = plt.subplot(1,1,1)\n\n#plot the disc at (0,1) with an angle of 0.5 radians\ndisc.render_body(ax=ax, p=(0,1,0.5), color = \"red\")\n</code></pre> <p>inputs</p> Attribute Type Description ax matplotlib.pyplot.Axes Axes object to render the body on p Tuple[float, float, float] Position and orientation to render the object at color String (optional) Color to render body, default depends on subclass <p>returns</p> <p>None.</p>"},{"location":"RunConfiguration/","title":"Run Configuration","text":"<p>Dataclass to store settings governing how a solver is executed.</p>"},{"location":"RunConfiguration/#attributes","title":"Attributes","text":"Attribute Type Description output_path string Filepath to save output files to output_name string Run name forming prefix for all output files output_as_csv bool Save output files as .csv (True) or as .npy (False), defaults to True output_position bool Option to save the calculated position data. Defaults to True output_velocity bool Option to save the calculated velocity data. Defaults to True output_acceleration bool Option to save the calculated force data. Defaults to True Solver_type \"RK4\", \"FwdEuler\", or \"CentralDifference\" Selected time integration method, see Solver for details termination_time float End time for simulation n_timesteps int number of timesteps to calculate between (0,termination_time), defaults to 1000 render_name string Name prefix for animator file, defaults to output_name animate_concise bool Option to animate only dynamics system motion (True) or animate system motion plus position vs time plots (False).  Defaults to True bodies_to_render List [int] List of bodies to include when animating results. defaults to all bodies body_colors List [string] List of colors to render bodies when animating n_frames int number of frames to generate out of full simulation length. Defaults to 100"},{"location":"RunConfiguration/#methods","title":"Methods","text":""},{"location":"RunConfiguration/#update_from_dict","title":"update_from_dict","text":"<p>update run properties from a dictionary</p> <pre><code>\nconfig_dict = {\n    \"output_path\": \"C:/path/to/output/file/\",\n    \"output_name\": \"example_run\",\n    \"solver_type\": \"RK4\",\n    \"termination_time\": 0.05,\n    \"n_timesteps\": 10000,\n    \"animate_concise\": True\n}\n\n#create configuration and update from dictionary\nrun_config = RunConfiguration()\nrun_config.update_from_dict(config_dict=config_dict)\n\n</code></pre> <p>inputs</p> Attribute Type Description config_dict dict dictionary containing name value pairs according to the attributes table above <p>returns</p> <p>RunConfiguration object</p>"},{"location":"RunConfiguration/#save_to_file","title":"save_to_file","text":"<p>Save run configuration to .json file for use in later simulations</p> <pre><code>\nconfig_dict = {\n    \"output_path\": \"C:/path/to/output/file/\",\n    \"output_name\": \"example_run\",\n    \"solver_type\": \"RK4\",\n    \"termination_time\": 0.05,\n    \"n_timesteps\": 10000,\n    \"animate_concise\": True\n}\n\n#create configuration and update from dictionary\nrun_config = RunConfiguration()\nrun_config.update_from_dict(config_dict=config_dict)\n\n#save to file\nrun_config.save_to_file(\"save/path/settings.json\")\n</code></pre> Attribute Type Description filename string Filename to save run config <p>Returns</p> <p>None</p>"},{"location":"RunConfiguration/#load_from_file","title":"load_from_file","text":"<p>Load run configuration from existing .json file</p> <pre><code>\n#create configuration and update from file\nrun_config = RunConfiguration()\n\nrun_config.load_from_file(\"save/path/settings.json\")\n</code></pre> Attribute Type Description filename string Filename to load run config <p>Returns</p> <p>None</p>"},{"location":"Solver/","title":"Solver","text":"<p>Class that stores and handles creation of a solution to a problem specified by a series of bodies, spring/dampers, and forces.</p>"},{"location":"Solver/#attributes","title":"Attributes","text":"Attribute Type Description solved bool Whether a solution to the given system has been found config RunConfiguration Settings for solution bodies list [RigidBody] Bodies included in the analysis n_bodies int number of bodies in the analysis springs list [SpringDamper] Spring/dampers included in the analysis n_springs int number of spring/dampers in the analysis bcs list [Force, Displacement] External boundary conditions included in the analysis solver \"RK4\", \"FwdEuler\", or \"CentralDifference\" Time integration type for analysis constraint list[int] list of constrained degrees of freedom m np.ndarray 1d vector of mass/inertia for each body in the analysis timesteps np.ndarray 1d vector of time points to evaluate n_timesteps int number of timesteps in the analysis dt float timestep for the analysis global_force_array np.ndarray Array of size (n_timesteps, 3*n_bodies) storing force and torque vs. time applied to each degree of freedom position_array np.ndarray Array of size (n_timesteps, 3*n_bodies) storing position vs. time for each degree of freedom velocity_array np.ndarray Array of size (n_timesteps, 3*n_bodies) storing velocity vs. time for each degree of freedom acceleration_array np.ndarray Array of size (n_timesteps, 3*n_bodies) storing acceleration vs. time for each degree of freedom"},{"location":"Solver/#methods","title":"Methods","text":""},{"location":"Solver/#_init_","title":"_init_","text":"<pre><code>class Solver:\n\n    def __init__(\n        self,\n        bodies: List[RigidBody],\n        springs: List[SpringDamper],\n        config: RunConfiguration,\n        bcs: List[Union[Force,Displacement]] = None,\n        verbose: bool = False,\n    ) -&gt; None:\n\n\n\n#create a rigid body\ndisc1 = Disc(ID=0,m=1.00,R=4.25,\n            cm=(0,0,0),name=\"body1\", \n            dof_constraint=(False, False, False))\n\n#connect to boundary using a linear spring\nspring = LinearSpringDamper(k=1000,c=10,\n                            p=0.0,parent=disc1, child_pos = (0.0,0.0),type=\"Linear\")\n\n#create a run configuration\nrun_config=RunConfiguration()\n\n#create a solver to perform analysis\nsol = Solver([disc1],[spring],run_config)\n\n</code></pre> Attribute Type Description bodies List [RigidBody] Bodies to include in the analysis springs List [SpringDamper] Spring/dampers to include in the analysis config RunConfiguration Run settings for analysis bcs List [Force, Displacement] (optional) External forces or prescribed motions for the analysis verbose bool Specify whether to print solution steps and timing to the command window <p>Returns</p> <p>Solver object</p>"},{"location":"Solver/#solve","title":"Solve","text":"<p>Calculate solution to defined problem</p> <pre><code>#create a solver to perform analysis\nsol = Solver([disc1],[spring],run_config)\n\n#print solution x-position (no solution yet, all zeros)\nprint(sol.position_array[:,0])\n\n#calculate solution to given problem\nsol.solve()\n\n#print solution x-position (solved, nonzero array)\nprint(sol.position_array[:,0])\n</code></pre> <p>Returns</p> <p>None</p>"},{"location":"SpringDamper/","title":"Spring/Dampers","text":"<p>A class to define non-rigid constraints between bodies using linear or rotational spring/damper series.</p>"},{"location":"SpringDamper/#core-attributes","title":"Core Attributes","text":"<p>The attributes below are universal to all springtypes.</p> Attribute Type Description k float Linear spring constant c float Linear damping constant p float initial spring compression constraint tuple [bool, bool, bool] (\\(x\\), \\(y\\), \\(\\theta\\)) spring/damper constraints, if True then spring/damper does not act along the specified axis parent int ID of body 1 connected to spring/damper.  Relative angles and positions measured relative to this body parent_r double Radius of parent body child int ID of body 2 connected to spring/damper child_r radius of child body xp, yp float Coordinates of parent body connection relative to parent body center of mass.  If parent body is None, then absolute coordinates of connection to rigid boundary xc, yc float Coordinates of child body connection relative to child body center of mass.  If child body is None, then absolute coordinates of connection to rigid boundary l0x, l0y, l0t float initial length (or angle) between the parent and child body.  Spring displacements are measured relative to this property. forcehist np.ndarray Array of shape (n_timestep, 4), with columns tracking the \\(x-\\) and \\(y-\\) force applied to the bodies, as well as the \\(\\theta_p-\\) and \\(\\theta_c-\\) torque applied to the parent and child bodies. <pre><code>class SpringDamper:\n\n    def __init__(\n        self,\n        k: float,\n        c: float,\n        p: float = 0.0,\n        parent: Optional[RigidBody] = None,\n        child: Optional[RigidBody] = None,\n        parent_pos: Tuple[float, float] = (0.0, 0.0),\n        child_pos: Tuple[float, float] = (0.0, 0.0),\n        dof_constraint: Tuple[bool, bool, bool] = (False, False, False)\n    ) -&gt; None:\n</code></pre>"},{"location":"SpringDamper/#linear-springdampers","title":"Linear Spring/Dampers","text":"<p>Linear spring/dampers are a generic element which can apply x- and y- forces to their parent and child bodies.  Torque can be applied to the parent and child bodies directly by defining the connection coordinates to be eccentric on the parent or child body.  Additional torque transfer can be defined through defining a spring force and damping force coupling coefficients, which enable the transfer of the normal spring/damper force to a tangential load similar to frictional effects.</p>"},{"location":"SpringDamper/#attributes","title":"Attributes","text":"<p>The attributes below are specific to the linear spring/damper class:</p> Attribute Type Description type \"Linear\", \"Tensile\", \"Compressive\", \"Tabular\" Spring force calculation method, see notes below mu tuple [float, float] Rotational wet and dry coupling coefficents, see notes below kcurve np.ndarray Force vs. displacement curve for tabular formulation, see notes below"},{"location":"SpringDamper/#methods","title":"Methods","text":""},{"location":"SpringDamper/#_init_","title":"_init_","text":"<p>Initialize a new linear spring/damper.</p> <pre><code>class LinearSpringDamper(SpringDamper):\n\n    def __init__(\n        self,\n        k: float,\n        c: float,\n        p: float = 0,\n        parent: Optional[RigidBody] = None,\n        child: Optional[RigidBody] = None,\n        parent_pos: Tuple[float] = (0, 0),\n        child_pos: Tuple[float] = (0, 0),\n        dof_constraint: Tuple[bool] = (False, False, False),\n        track_force: bool = False,\n        type: Literal[\"Linear\", \"Tensile\", \"Compressive\", \"Tabular\"] = \"Linear\",\n        curve: np.ndarray = None,\n        mu:Tuple[float] = (0.0,0.0)\n    ) -&gt; None:\n\n#Define a spring connecting two rigid bodies, \n#initially compressed and connected eccentrically to the child body, and track the force history\nspring12 = LinearSpringDamper(k=1000, c=10, p=-0.001, \n                              parent=body1, child=body2, child_pos=(0.1, 0))\n\n#Define a compression-only spring with rotational coupling connected to the boundary\nspring12 = LinearSpringDamper(k=1000, c=10, p=-0.001, \n                              parent=body1, type = \"Compressive\", \n                              mu=(0.05, 0.001))\n</code></pre> <p>Inputs</p> Attribute Type Description k float Linear spring constant c float Linear damping constant p float Initial spring displacement (positive = tension) parent RigidBody Connected body 1 (optional) child RigidBody Connected body 2 (optional) parent_pos tuple [float, float] (optional) x- and y- position of spring connection to parent body, defaults to None child_pos tuple [float, float] (optional) x- and y- position of spring connection to child body, defaults to None dof_constraint tuple [bool, bool, bool] (optional) degrees of freedom which the spring acts along, defaults to all DOF active type \"Linear\", \"Tensile\", \"Compressive\", \"Tabular\" (optional) Spring formulation, see notes below, defaults to Linear curve np.ndarray (optional) Force vs. displacement curve for tabular formulation, defaults to None mu tuple [float, float] (optional) Wet and dry rotational coupling, defaults to no coupling (0,0) <p>Returns</p> <p>LinearSpringDamper object</p>"},{"location":"SpringDamper/#notes","title":"Notes","text":"<p>Spring displacement calculation:</p> <p>Each spring/damper connects to a parent body (denoted \\(x_p\\))to a child body (denoted \\(x_c\\)).  A generic linear spring/damper connecting two bodies at an arbitrary point on each body \\((\\delta x_p, \\delta y_p)\\) and \\((\\delta x_c, \\delta y_c)\\), the relative position and velocity of the connection points is given by:</p> <p>\\(\\vec{r}_p = \\langle x_p + \\delta x_p \\cos{\\theta_p} - \\delta y_p \\sin{\\theta_p}, y_p + \\delta y_p \\cos{\\theta_p} + \\delta x_p \\sin{\\theta_p}\\rangle\\)</p> <p>\\(\\vec{v}_p = \\langle \\dot{x}_p + \\dot{\\theta}_p (- \\delta x_p\\sin{\\theta_p} - \\delta y_p \\cos{\\theta_p}), \\dot{y}_p + \\dot{\\theta}_p (-\\delta y_p \\sin{\\theta_p} + \\delta x_p \\cos{\\theta_p})\\rangle\\)</p> <p>Subsequently, the relative displacement and velocity of the parent and child attachment points are given by:</p> <p>\\(\\vec{r}_{rel} = \\langle r_{px}-r_{cx}-l_{0x}, r_{py}-r_{cy}-l_{0y} \\rangle = \\langle \\Delta r_x, \\Delta r_y \\rangle\\)</p> <p>\\(\\vec{v}_{rel} = \\langle v_{px}-v_{cx}, v_{py}-v_{cy} \\rangle = \\langle \\Delta v_x, \\Delta v_y \\rangle\\)</p> <p>Spring and damper forces for each spring are calculated from the relative lengths and velocities calculated above.</p> <p>Spring types:</p> <p>Four formulations are available for the linear spring/damper.  The \"Linear\" option relates force to displacement using Hooke's law:</p> <p>\\(\\vec{F}_k=k(||\\vec{r}_{rel}||-l_0)\\)</p> <p>\\(\\vec{F}_c=c||\\vec{v}_{rel}||\\)</p> <p>The \"Compressive\" option relates force to displacement using Hooke's law only when the spring stretch is less than zero.  The \"Tensile\" option similarly only applies a force when the spring is in Tension.</p> <p>The \"Tabular\" option allows the definition of an arbitrary force vs. displacement curve.  Force will be interpolated along the curve during each force calculation.  this formulation is a work in progress</p> <p>Rotational coupling:</p> <p>Torque may be applied by the spring due to an eccentric connection to the body creating a moment.  Additional coupling can be prescribed by specifying values \\(\\mu_k\\) and \\(\\mu_c\\) which transfer a portion of the spring and damper forces to a torque on the body.  The coefficients \\(\\mu_k\\) and \\(\\mu_c\\) are analogous to specifying a moment arm which the spring and damper forces will act on on the body:</p> <p>\\(T_{spring} = \\vec{r} \\times \\vec{F}_{spring} + \\mu_k ||\\vec{F}_{spring}||(\\theta_p - \\theta_c) - \\mu_c ||\\vec{F}_{spring}||(\\omega_p - \\omega_c)\\)</p>"},{"location":"SpringDamper/#rotational-springdamper","title":"Rotational Spring/Damper","text":"<p>Rotational spring/dampers are a generic element which can apply Torque to bodies based on their relative angle and angular velocity.</p>"},{"location":"SpringDamper/#methods_1","title":"Methods","text":""},{"location":"SpringDamper/#_init__1","title":"_init_","text":"<p>Initialize a new rotational spring/damper.</p> <pre><code>class RotationalSpringDamper(SpringDamper):\n\n    def __init__(\n        self,\n        k: float,\n        c: float,\n        p: float = 0,\n        parent: Optional[RigidBody] = None,\n        child: Optional[RigidBody] = None,\n        dof_constraint: Tuple[bool] = (False, False, False),\n    ) -&gt; None:\n\n#Define a rotational spring connecting two rigid bodies\nspring12 = RotationalSpringDamper(k=1000, c=10, p=-0.001, \n                              parent=body1, child=body2)\n\n</code></pre> <p>Inputs</p> Attribute Type Description k float Linear spring constant c float Linear damping constant p float Initial spring displacement (positive = tension) parent RigidBody Connected body 1 (optional) child RigidBody Connected body 2 (optional) dof_constraint tuple [bool, bool, bool] (optional) degrees of freedom which the spring acts along, defaults to all DOF active <p>Returns</p> <p>Rotational spring/damper object</p>"},{"location":"template/","title":"Array Keywords","text":"<p>A special type ofthe keyword object that enables easier editing of the properties of long, list-style keywords such as nodes or elements.  </p>"},{"location":"template/#attributes","title":"Attributes","text":"Attribute Type Description self.title String Keyword name self.name String array name (e.g., name of a part set) if applicable, otherwise None self.string String Ascii contents of the keyword self.format String Keyword file type, \"short\" (comma separated), \"fixed\" (standard PrePost format), or \"Long\" (double length PrePost format) self.range list[int] Start and end character index of the keyword self.headercards int Number of control cards prior to list (e.g., ID and solver properties on node sets) self.cards list[Card] List containing header cards self.arrayrange list[int] start and end character of array entries in the keyword self.width int number of entries in each line of the array self.array np.ndarray Array containing the nodal coordinates"},{"location":"template/#subclasses","title":"subclasses","text":"<p>All subclasses share the same methods detailed below, but configure a specific type of keyword array with the correct entry widths and number of header cards:</p> <ul> <li>Nodes (node array)</li> <li>Elements (shell, tshell, beam, or solid element array)</li> <li>Set (part, node, or segment set)</li> </ul> <pre><code>\nclass Nodes(ArrayKeyword):\n    headercards=0\n    width=6\n\nclass Elements(ArrayKeyword):\n    headercards=0\n    width=10\n\nclass Set(ArrayKeyword):\n    headercards=1\n    width=8\n\n</code></pre>"},{"location":"template/#methods","title":"Methods","text":""},{"location":"template/#init","title":"init","text":"<p>Initialize a new array keyword</p> <pre><code>class ArrayKeyword:\n    def __init__(self, input_string: str, input_range: list[int], format:str):\n\nf=KeywordFile(\"/path/to.k\",\"fixed\")\nnodal_coords=f.get_nodes()\n</code></pre> <p>inputs</p> Attribute Type Description input_string String Ascii contents of the keyword format String Keyword file type, \"short\" (comma separated), \"fixed\" (standard PrePost format), or \"Long\" (double length PrePost format) input_range list[int] Start and end character index of the keyword <p>returns</p> <p>Array Keyword object</p>"},{"location":"template/#update_string","title":"update_string","text":"<p>Update the contents of self.string to reflect any changes applied</p> <pre><code>def update_string(self):\n\nf=KeywordFile(\"/path/to.k\",\"fixed\")\nnodal_coords=f.get_nodes()\n\nnode_set=[0,1,2,3,4]\n\ntransform_operator=Transformation()\ntransform_operator.scale(2,0,0)\n\nnodal_coords.transform(node_set,transform_operator)\nnodal_coords.update_string()\n\nf.replace_keyword(nodal_coords)\n</code></pre> <p>inputs</p> <p>None</p> <p>returns</p> <p>Updates self.string to reflect changes made.</p>"},{"location":"template/#node-class-methods","title":"Node class methods","text":""},{"location":"template/#transform","title":"Transform","text":"<p>Applies a pre-defined series of transformations to a set of nodes</p> <pre><code>def transform(self, node_set, operator):\n\nf=KeywordFile(\"/path/to.k\",\"fixed\")\nnodal_coords=f.get_nodes()\n\nnode_set=[0,1,2,3,4]\n\ntransform_operator=Transformation()\ntransform_operator.scale(2,0,0)\n\nnodal_coords.transform(node_set,transform_operator)\n\n</code></pre> <p>inputs</p> Attribute Type Description node_set list[int] indices of each node to apply the transformation to operator Transformation Pre-defined transformation operator containing a specified transformation matrix. <p>returns</p> <p>Updates the nodal array with new x,y,z coordinates for the node subset.</p>"}]}